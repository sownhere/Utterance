// The MIT License (MIT)
// Copyright (c) 2024 Utterance

import Foundation
import PipelineModels
import os

/// Logic to separate a continuous stream of text into distinct statements.
///
/// This processor monitors the stream of text and handles:
/// 1. Punctuation-based splitting (if enabled)
/// 2. Silence-based splitting (managed externally via timers, but logic resides here)
/// 3. Accumulating partial results until a split occurs.
public final class StatementSeparator: @unchecked Sendable {

    // MARK: - Types

    /// Result of processing a partial segment.
    enum ProcessingResult {
        /// The segment continues, updated pending text.
        case continuous(String)
        /// A split occurred, yielding a finalized item and remaining text.
        case split(item: TranscriptItem, remaining: String)
    }

    // MARK: - State

    private struct State {
        var lastUpdateTime: Date = Date()
        var pendingText: String = ""
        var currentStartTime: TimeInterval = 0
    }

    // MARK: - Properties

    /// Minimum pause duration to trigger a split (in seconds).
    private let silenceThreshold: TimeInterval

    /// Lock for thread-safe state access.
    private let lock = OSAllocatedUnfairLock(initialState: State())

    // MARK: - Initialization

    /// Creates a new statement separator.
    ///
    /// - Parameter silenceThreshold: Minimum silence to trigger split (default 1.5s)
    public init(silenceThreshold: TimeInterval = 1.5) {
        self.silenceThreshold = silenceThreshold
    }

    // MARK: - Processing

    /// Processes a new partial text update.
    ///
    /// - Parameters:
    ///   - text: The latest partial text from the recognizer.
    ///   - timestamp: The end timestamp of this update.
    ///   - isFinal: Whether the recognizer considers this final.
    /// - Returns: A list of finalized items generated by this update.
    public func process(
        text: String,
        timestamp: TimeInterval,
        isFinal: Bool
    ) -> [TranscriptItem] {
        lock.withLock { state in
            var items: [TranscriptItem] = []

            // Simple logic: If we detect terminal punctuation, we split.
            // In a real stream, we might need diffing logic if 'text' is cumulative.
            // Assuming 'text' here is the *snapshot* of the current unfinalized buffer.

            if isFinal {
                // Force flush everything
                if !text.isEmpty {
                    let item = TranscriptItem(
                        text: text,
                        start: state.currentStartTime,
                        end: timestamp
                    )
                    items.append(item)
                }
                reset(state: &state, startTime: timestamp)
                return items
            }

            // Check for punctuation end
            if let lastChar = text.last, isTerminalPunctuation(lastChar) {
                let item = TranscriptItem(
                    text: text,
                    start: state.currentStartTime,
                    end: timestamp
                )
                items.append(item)
                reset(state: &state, startTime: timestamp)  // Next item starts where this one ended
                return items
            }

            // Update state
            state.pendingText = text
            state.lastUpdateTime = Date()

            return items
        }
    }

    /// Checks for silence timeout.
    ///
    /// Call this periodically (e.g. every 0.1s) to check if we should force close the current statement.
    ///
    /// - Parameter currentTime: The current audio timestamp
    /// - Returns: A finalized item if silence threshold exceeded, otherwise nil.
    public func checkSilence(currentTime: TimeInterval) -> TranscriptItem? {
        lock.withLock { state in
            guard !state.pendingText.isEmpty else { return nil }

            let timeSinceUpdate = -state.lastUpdateTime.timeIntervalSinceNow

            if timeSinceUpdate > silenceThreshold {
                let item = TranscriptItem(
                    text: state.pendingText,
                    start: state.currentStartTime,
                    end: currentTime
                )
                reset(state: &state, startTime: currentTime)
                return item
            }

            return nil
        }
    }

    // MARK: - Private Helpers

    private func reset(state: inout State, startTime: TimeInterval) {
        state.pendingText = ""
        state.currentStartTime = startTime
        state.lastUpdateTime = Date()
    }

    private func isTerminalPunctuation(_ char: Character) -> Bool {
        return char == "." || char == "?" || char == "!"
    }
}
